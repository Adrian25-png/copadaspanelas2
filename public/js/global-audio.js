/**
 * Sistema de √°udio global com sincroniza√ß√£o em tempo real
 */

class GlobalSyncAudio {
    constructor() {
        this.audio = null;
        this.syncInterval = null;
        this.positionInterval = null;
        this.currentPage = this.getCurrentPageName();
        this.currentMedia = null;
        this.isInitialized = false;
        this.isPaused = false; // Controle de pausa externa
        this.syncTolerance = 0.5; // Toler√¢ncia de sincroniza√ß√£o em segundos
        this.lastSyncTime = 0;
        this.init();
    }

    getCurrentPageName() {
        const path = window.location.pathname;
        const filename = path.split('/').pop();
        return filename.replace('.php', '');
    }

    init() {
        console.log(`üéµ Inicializando sistema de √°udio sincronizado na p√°gina: ${this.currentPage}`);

        // Verificar sincroniza√ß√£o global imediatamente
        this.checkGlobalSync();

        // Verificar sincroniza√ß√£o a cada 3 segundos
        this.syncInterval = setInterval(() => {
            this.checkGlobalSync();
        }, 3000);

        // Monitorar posi√ß√£o do √°udio a cada segundo
        this.positionInterval = setInterval(() => {
            this.monitorAudioPosition();
        }, 1000);

        // Escutar eventos de visibilidade da p√°gina
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && !this.isPaused) {
                // P√°gina ficou vis√≠vel, re-sincronizar imediatamente
                console.log('üëÅÔ∏è P√°gina vis√≠vel, re-sincronizando...');
                setTimeout(() => this.checkGlobalSync(), 100);
            }
        });

        // Re-sincronizar quando a janela ganha foco
        window.addEventListener('focus', () => {
            if (!this.isPaused) {
                console.log('üéØ Janela em foco, re-sincronizando...');
                setTimeout(() => this.checkGlobalSync(), 100);
            }
        });
    }

    async checkGlobalSync() {
        // Se o sistema est√° pausado, n√£o fazer nada
        if (this.isPaused) {
            return;
        }

        try {
            const response = await fetch('/copadaspanelas2/app/api/audio_sync.php');
            const data = await response.json();

            if (data.success && data.sync_data) {
                await this.handleSyncData(data.sync_data);
            } else {
                this.stopAudio();
            }
        } catch (error) {
            console.log('‚ùå Erro na sincroniza√ß√£o:', error);
        }
    }

    async handleSyncData(syncData) {
        // Verificar se deve tocar na p√°gina atual
        if (!this.shouldPlayOnCurrentPage(syncData)) {
            this.stopAudio();
            return;
        }

        // S√≥ processar m√∫sica sem controles visuais
        if (syncData.media_type !== 'music' || syncData.show_controls) {
            this.stopAudio();
            return;
        }

        // Verificar se a m√≠dia mudou
        const mediaChanged = !this.currentMedia ||
                           this.currentMedia.media_id !== syncData.media_id ||
                           this.currentMedia.file_path !== syncData.file_path;

        // Atualizar dados da m√≠dia atual
        this.currentMedia = syncData;

        if (mediaChanged) {
            console.log('üéµ Nova m√≠dia detectada:', syncData.title);
            await this.startSyncedAudio(syncData);
        } else {
            // Verificar se precisa sincronizar posi√ß√£o
            await this.syncAudioPosition(syncData);
        }
    }

    async startSyncedAudio(syncData) {
        if (!syncData.file_path) {
            console.log('‚ùå Caminho do arquivo n√£o encontrado');
            return;
        }

        const audioSrc = `/copadaspanelas2/${syncData.file_path}`;

        // Se j√° est√° tocando a mesma m√∫sica, apenas sincronizar posi√ß√£o
        if (this.audio && this.audio.src.includes(syncData.file_path) && !this.audio.paused) {
            console.log('üîÑ M√∫sica j√° tocando, apenas sincronizando posi√ß√£o...');
            await this.syncAudioPosition(syncData);
            return;
        }

        // Parar √°udio anterior apenas se for diferente
        if (this.audio && !this.audio.src.includes(syncData.file_path)) {
            console.log('üîÑ Trocando para nova m√∫sica...');
            this.stopAudio();
        }

        // Se n√£o h√° √°udio ou est√° pausado, criar/retomar
        if (!this.audio) {
            console.log('üéµ Criando novo elemento de √°udio:', audioSrc);
            this.audio = new Audio(audioSrc);
            this.audio.loop = syncData.loop_enabled;
            this.audio.volume = 0.3;
            this.audio.preload = 'auto';

            // Aguardar carregamento
            try {
                await new Promise((resolve, reject) => {
                    this.audio.addEventListener('canplaythrough', resolve, { once: true });
                    this.audio.addEventListener('error', reject, { once: true });

                    // Timeout de 10 segundos
                    setTimeout(() => reject(new Error('Timeout no carregamento')), 10000);
                });
            } catch (error) {
                console.log('‚ùå Erro no carregamento:', error);
                return;
            }
        }

        // Calcular posi√ß√£o correta
        const targetPosition = syncData.current_position;

        if (targetPosition > 0 && targetPosition < syncData.duration) {
            this.audio.currentTime = targetPosition;
        }

        // Iniciar reprodu√ß√£o se n√£o estiver tocando
        if (this.audio.paused) {
            try {
                await this.audio.play();
                console.log(`‚úÖ √Åudio sincronizado iniciado na posi√ß√£o ${targetPosition.toFixed(2)}s`);
                this.showSyncIndicator(syncData.title, targetPosition);
            } catch (error) {
                console.log('‚ùå Autoplay bloqueado:', error);
            }
        }
    }

    async syncAudioPosition(syncData) {
        if (!this.audio) {
            // Se n√£o h√° √°udio mas deveria ter, iniciar
            if (syncData.is_playing) {
                await this.startSyncedAudio(syncData);
            }
            return;
        }

        if (this.audio.paused && syncData.is_playing) {
            // Se √°udio est√° pausado mas deveria estar tocando, retomar
            try {
                this.audio.currentTime = syncData.current_position;
                await this.audio.play();
                console.log('‚ñ∂Ô∏è √Åudio retomado na posi√ß√£o', syncData.current_position.toFixed(2));
            } catch (error) {
                console.log('‚ùå Erro ao retomar √°udio:', error);
            }
            return;
        }

        if (!this.audio.paused) {
            const currentAudioTime = this.audio.currentTime;
            const expectedTime = syncData.current_position;
            const timeDifference = Math.abs(currentAudioTime - expectedTime);

            // Se a diferen√ßa for maior que a toler√¢ncia, sincronizar
            if (timeDifference > this.syncTolerance) {
                console.log(`üîÑ Sincronizando posi√ß√£o: ${currentAudioTime.toFixed(2)}s ‚Üí ${expectedTime.toFixed(2)}s (diff: ${timeDifference.toFixed(2)}s)`);

                // Ajustar posi√ß√£o
                this.audio.currentTime = expectedTime;

                // Se a diferen√ßa for muito grande, pode ser necess√°rio pausar e reproduzir novamente
                if (timeDifference > 3.0) {
                    try {
                        await this.audio.play();
                    } catch (error) {
                        console.log('‚ùå Erro ao re-sincronizar:', error);
                    }
                }
            }
        }
    }

    monitorAudioPosition() {
        if (!this.audio || this.audio.paused || !this.currentMedia) {
            return;
        }

        // Verificar se o √°udio ainda est√° tocando corretamente
        const now = Date.now();
        if (now - this.lastSyncTime > 10000) { // Re-sincronizar a cada 10 segundos
            this.checkGlobalSync();
            this.lastSyncTime = now;
        }

        // Verificar se chegou ao fim (para √°udios sem loop)
        if (!this.currentMedia.loop_enabled &&
            this.audio.currentTime >= this.currentMedia.duration) {
            console.log('üîö √Åudio terminou');
            this.stopAudio();
        }
    }

    shouldPlayOnCurrentPage(syncData) {
        // Se target_pages √© null ou vazio, tocar em todas as p√°ginas
        if (!syncData.target_pages) {
            console.log(`‚úÖ Deve tocar na p√°gina ${this.currentPage}: SIM (todas as p√°ginas)`);
            return true;
        }

        try {
            const targetPages = JSON.parse(syncData.target_pages);
            const shouldPlay = targetPages.includes(this.currentPage);
            console.log(`${shouldPlay ? '‚úÖ' : '‚ùå'} Deve tocar na p√°gina ${this.currentPage}: ${shouldPlay ? 'SIM' : 'N√ÉO'} (p√°ginas alvo: ${targetPages.join(', ')})`);
            return shouldPlay;
        } catch (error) {
            console.log(`‚úÖ Deve tocar na p√°gina ${this.currentPage}: SIM (erro no JSON, fallback)`);
            return true; // Se erro no JSON, tocar em todas
        }
    }

    stopAudio() {
        if (this.audio) {
            this.audio.pause();
            this.audio = null;
        }
        this.currentMedia = null;
        this.hideSyncIndicator();
        console.log('üîá Sistema de √°udio global parado');
    }

    // M√©todo p√∫blico para pausar temporariamente o sistema
    pauseSystem() {
        this.stopAudio();
        this.isPaused = true;
        console.log('‚è∏Ô∏è Sistema de √°udio global pausado temporariamente');
    }

    // M√©todo p√∫blico para retomar o sistema
    resumeSystem() {
        this.isPaused = false;
        console.log('‚ñ∂Ô∏è Sistema de √°udio global retomado');
        // Verificar imediatamente se h√° m√≠dia para tocar
        setTimeout(() => this.checkGlobalSync(), 100);
    }

    showSyncIndicator(title, position) {
        this.hideSyncIndicator();

        const indicator = document.createElement('div');
        indicator.id = 'copa-sync-indicator';
        indicator.innerHTML = `
            <div style="
                position: fixed;
                top: 20px;
                right: 20px;
                background: linear-gradient(45deg, #7B1FA2, #9C27B0);
                color: white;
                padding: 12px 16px;
                border-radius: 25px;
                font-size: 13px;
                font-weight: 600;
                z-index: 9999;
                display: flex;
                align-items: center;
                gap: 10px;
                box-shadow: 0 6px 20px rgba(123, 31, 162, 0.4);
                animation: slideInSync 0.4s ease-out;
                max-width: 300px;
            ">
                <div style="
                    width: 10px;
                    height: 10px;
                    background: #4CAF50;
                    border-radius: 50%;
                    animation: syncPulse 1.5s infinite;
                "></div>
                <div style="display: flex; flex-direction: column; gap: 2px;">
                    <div>üéµ ${title}</div>
                    <div style="font-size: 11px; opacity: 0.8;">
                        Sincronizado ‚Ä¢ ${this.formatTime(position)}
                    </div>
                </div>
            </div>
            <style>
                @keyframes slideInSync {
                    from { transform: translateX(100%); opacity: 0; }
                    to { transform: translateX(0); opacity: 1; }
                }
                @keyframes syncPulse {
                    0%, 100% { opacity: 1; transform: scale(1); }
                    50% { opacity: 0.6; transform: scale(1.2); }
                }
            </style>
        `;

        document.body.appendChild(indicator);

        // Remover ap√≥s 4 segundos
        setTimeout(() => {
            this.hideSyncIndicator();
        }, 4000);
    }

    hideSyncIndicator() {
        const indicator = document.getElementById('copa-sync-indicator');
        if (indicator) {
            indicator.remove();
        }
    }

    formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    destroy() {
        console.log('üîÑ Limpando sistema de √°udio...');

        if (this.syncInterval) {
            clearInterval(this.syncInterval);
        }
        if (this.positionInterval) {
            clearInterval(this.positionInterval);
        }

        // N√£o parar o √°udio ao trocar de p√°gina - deixar tocando
        // this.stopAudio();

        this.hideSyncIndicator();
    }

}

// Inicializar sistema de √°udio sincronizado
document.addEventListener('DOMContentLoaded', function() {
    // Evitar m√∫ltiplas inst√¢ncias
    if (window.globalSyncAudio) {
        console.log('üéµ Sistema de √°udio j√° inicializado, pulando...');
        return;
    }

    console.log('üéµ Carregando sistema de √°udio sincronizado...');
    window.globalSyncAudio = new GlobalSyncAudio();
});

// Limpar ao sair da p√°gina
window.addEventListener('beforeunload', function() {
    if (window.globalSyncAudio) {
        window.globalSyncAudio.destroy();
    }
});
